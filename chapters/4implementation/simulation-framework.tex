\section{Simulation Framework}
%\begin{figure}[H]
%	\centering
%	\input{chapters/4implementation/diagram-simulation-framework}
%	\caption{Functions of the Simulation Framework}
%	\label{diag:simulationFramework}
%\end{figure}

The simulation framework consists of the functions and methods not directly related to the localisation estimation and source tracking. The different parts of this framework are shown in yellow in Figure \ref{diag:simulationFramework} and will be explained in the following subsections.

\subsection{Set Parameters}
The \code{config_update} function initializes all parameters, variables and constants required by the remaining functions and methods. This is done up front to have easy access to the parameter set and a single file to adjust when a different configuration is needed. It provides a set of default parameters, that can be overriden by input arguments. This way, each evaluation script can call \code{config_update} with it's specific set of adjustments to the default configuration without the need to adjust the function itself or redefine all other values. The list of default parameters is provided in \ref{app:defaultParameters}.
The function also relies on two helper functions, namely \code{get_random_sources} and \code{get_trajectory_from_source}. The first ensures, that the random positions of the sources comply with the location constraints expressed in section \ref{sec:setup}, whereas the latter takes source positions and movement vectors and returns a trajectory vector, which is needed to compute the \gls{rir} of a moving source.

\subsection{Simulate Environment}
The \code{simulate} function takes care the simulation of the received signal. Therefore, it first has to acquire the \gls{rir} for each source-receiver combination. For the simulation of the \gls{rir} for the static location estimation case, the \emph{\gls{rir}-Generator}, an implementation of the image method described in chapter \ref{chap:2theory} by EmanuÃ«l \citet*{Habets2014}, is used. Although the premise of the image method was to reduce computational complexity and therefore execution time on a CPU, a total of 168 \glspl{rir} (24 microphones for 7 sources) had to be computed for this setup, which added up to significant delays when testing parts of the implementation. The \gls{rir} simulation took about 40 seconds on average for a trial with the base configuration. Choosing \code{T60=1.0s} and the maximum reflection order for 7 sources results in execution times of more than 2 minutes, which is quite long but was deemed acceptable for the static case. For the source trajectory simulation however, execution time of the \gls{rir}-Generator is prohibitively high. Therefore, the \emph{fastISM} package by \citeauthor{Lehmann2010} is used, which achieves reduced computational complexity by statistically approximating the reverberation tail of the \gls{rir} instead of calculating all higher-order reflections according to the image-method. \citeauthor{Lehmann2010} reported a possible speed-up factor of up to 150 with \code{R60=0.9} within his testing environment. For a thorough comparison of this technique and its gains in execution speed compared to the traditional implementations of the image-method across different configurations, see \cite{Lehmann2010}.

After the \gls{rir} is generated, the speech samples are loaded from the filesystem and resampled to the common sample rate chosen in the configuration (default: $f_s=16kHz$). Then, additive white gaussian noise is applied with the \code{SNR} value provided in the configuration. For the simulation to conclude, the source signals are now convoluted with the \gls{rir} and mixed together for each microphone, which results in the received signal $x_m^i(t)$. For the convolution, the \matlab function \code{fftfilt} is used, which implements the overlap-add method using the FFT and providing default parameters for efficient execution.

\subsection{Calculate Estimation Error}
After the source localisation algorithm has concluded and returned the position estimates, each of these estimates has to be matched to its true location in order to calculate the estimation error. The function \code{assign_estimates(loc_est, loc_true)} does this by choosing a permutation of the estimates $p_s$ that minimises the distance from the estimates to their true positions $p_{\text{true}}$. Whenever an assignment has been found, the respective positions (estimate and true) are removed. This is repeated until all estimates have been assigned.
%\begin{equation} %TODO: Check, whether this mathematical formulation for random permutations is valid
%    p_{s, \text{sorted}}=\min_{p_s}{\|p_s-p_{j,\text{true}}\|}\ \forall s,j\ \in\ \{1, 2, \dots, S\}
%\end{equation}
