\section{Implementation Details}
\label{chap:implementation}

Before any results can be produced, the described algorithms and setup have to be implemented and tested within a simulation framework, that allows for easy parameter customisation and evaluation. Therefore, what follows is the description of the different parts of the implementation that allows for the evaluation of the algorithms described in chapter \ref{chap:algorithms}. First, the setup is defined and the simulation framework is laid out. Then, the implementation of both source localisation and source tracking are discussed. Last, certain evaluation scenarios are established to analyse the possibilities and limitations of this implementation. This will assist in drawing conclusions about the strengths and shortcomings of the algorithm in this particular setup and may allow for more general findings to be deducted.

\paragraph{Computational Complexity} As computational complexity, and therefore execution time, is one of the measures to compare different algorithms and their implementations, the hardware on which these evaluations have been executed, needs to be mentioned. All trials and profiling benchmarks have been done on a Retina Macbook Pro 13" (MGX92LL/A), that is equipped with a 2.8 GHz Core i5-4308U CPU and 16GB of DDR3L-1600Mhz RAM. As the implementation is not parallelized, all computations have been executed solely on a CPU, although \matlab will utilise both cores of the i5 for certain operations.

While trying to replicate the results from \cite{Schwartz2014} for the static case, the 16GB RAM did not suffice the memory requirements of the fully vectorized implementation of the algorithm. Therefore, these trials have been carried out on different hardware with 32GB RAM, which was utilized to almost full capacity. This is due to the fact, that they did not restrict the grid points $\pall$ to only include the positions within the rectangle the microphone array describes, which increased $|\p|$ from $41 \cdot 41 = 1681$ to $61\cdot61=3721$, more than double in size. They also choose a wider frequency band (64 frequency bins instead of 24). Lastly, in their implementation the Gaussian component weights $\psips$ are calculated seperately for each source, doubling the size of the intermediary results for each \gls{em} yet again. The size of the largest temporary results in matlab with these parameters is $~30$GB.
