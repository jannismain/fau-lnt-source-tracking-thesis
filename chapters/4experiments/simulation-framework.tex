\subsection{Simulation Framework}
 % Tree visualisation of the src directory, containing the files config-update, simulate, em-algorithm, find-maxima and assign-estimates
\begin{figure}[H]
	\centering
	\input{data/figures/simulation-framework}
	\caption{Main Functions of the Simulation Framework.}
	\label{diag:simulationFramework}
\end{figure}

The simulation framework consists of the functions and methods not directly related to the actual source localisation and tracking, which have been described in detail in \autoref{chap:algorithms}. A brief introduction to the procedure of running different trials with varying parameter sets shall be given in the following section to provide a better understanding of the evaluation process and facilitate the ability to reproduce the results of this thesis.

\paragraph{Trial Procedure}
At the beginning of every trial, a parameter set has to be defined and saved in a way to be accessed by all routines throughout the runtime of the trial. Then, the environment is simulated and, within this environment, the received signals can be computed. The received signals for each microphone pair are obtained by convoluting the simulated room impulse response with the source signals, summing up the results per microphone and adding an amount of noise, that corresponds to the \gls{snr} defined in the parameter set. This signal is now transformed into the \gls{stft}-domain, in order for the \gls{prp} measure to be computed. For the \gls{stft}, a hanning-window of $0.05$~seconds and a step size of $0.01$~seconds have been selected. This concludes the preparation of the input parameters for either the source localisation or source tracking algorithm.


After the algorithm is executed, the location estimates, together with intermediary results, like the variances and weights of each Gaussian component per \gls{em} iteration, are returned. This data is now used to analyse, how good the source localisation or source tracking performed. For this purpose, the location estimates are assigned to their true source locations, according to the guidelines stated in \autoref{sec:performanceMeasure}, and the estimation error is calculated. When there are many trials with the same parameter set and only varying source locations (this is the case for the evaluation trials of the source localisation algorithm described in \autoref{sec:evalScenariosLoc}), the estimation error is then aggregated, after all trials of this type have been executed, and visualised through box plots, which summarise the results in a way so that they are easily comparable.


\paragraph{Simulating Sources in Reverberant Conditions}
Most of the computational complexity, apart from the actual algorithms themselves, accrue when simulating the \gls{rir} for multiple sources and microphones. For the simulation of the \gls{rir} for the static location estimation case, the \emph{\gls{rir}-Generator}, an implementation of the image method described in \autoref{chap:2theory} by EmanuÃ«l \citet*{Habets2014}, is used. Although the premise of the image method is to reduce computational complexity and therefore execution time on a CPU, a total of 168 \glspl{rir} for trials with 7 sources and 24 microphones had to be computed for this setup, which accumulates to substantial execution times when running trials with a sufficient sample size. The simulation of these 168 \glspl{rir} took about 40 seconds on average for a trial with the base configuration. Choosing T$_{60}=1.0$~s and the maximum reflection order for 7 sources results in execution times of more than 2 minutes per simulation, which is quite long but was deemed acceptable for the static case. For the source trajectory simulation however, the execution time of the \gls{rir}-Generator is prohibitively high. Therefore, the \emph{fastISM} package \cite{Lehmann2012} by \citeauthor{Lehmann2010} is used, which achieves reduced computational complexity by statistically approximating the diffuse reverberation instead of calculating all higher-order reflections exactly \cite{Lehmann2008,Lehmann2010}. The authors reported a possible speed-up factor of up to 150 at \Tsixty$=0.9$~s within their testing environment. For a thorough comparison of this technique and its gains in execution speed compared to the traditional implementations of the image-method across different configurations, see \cite{Lehmann2010}.